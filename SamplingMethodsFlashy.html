<!--
Notice: this file contains code from other authors which may be covered by other copyrights:
1) The Ziggurat Normal Distribution is taken from https://www.filosophy.org/post/35/normaldistributed_random_values_in_javascript_using_the_ziggurat_algorithm/
//-->
<html>
<head>
<link
	href="https://fonts.googleapis.com/css?family=Cardo|Open+Sans:400,400i,600|Material+Icons"
	rel="stylesheet">
<script type="text/javascript"
	src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>
<style type="text/css">
html, body {
	padding: 0px;
	font: 750 32px/1.5em Cardo, Georgia, serif;
	color: white;
	font-size: 21px;
}

/* Bret Victor style 'Tangle' inspired links (http://worrydream.com/Tangle/) */
a:hover {
	color: #ddf;
	border-color: #ddf;
	text-decoration: none;
}

a {
	font-family: Cardo, Georgia, serif;
	color: #ddf;
	border-bottom: 3px dotted #ddf;
	padding: 0px 1px;
	cursor: pointer;
	text-decoration: none;
}

/* The modal text box is based on code from: http://www.w3schools.com/howto/howto_css_modals.asp */

/* The Modal (background) */
.modal {
	display: none; /* Hidden by default */
	position: fixed; /* Stay in place */
	z-index: 1; /* Sit on top */
	padding-top: 100px; /* Location of the box */
	left: 0;
	top: 0;
	width: 100%; /* Full width */
	height: 100%; /* Full height */
	overflow: auto; /* Enable scroll if needed */
	background-color: rgb(0, 0, 0); /* Fallback color */
	background-color: rgba(0, 0, 0, 0.4); /* Black w/ opacity */
}

/* Modal Content */
.modal-content {
	background-color: #fefefe;
	margin: auto;
	padding: 20px;
	border: 1px solid #888;
	width: 80%;
}

/* ------------------------------------------------------------------------------------------------------------------- */
/* all of this style code just styles the input slider (autogenerated from http://www.cssportal.com/style-input-range/) */
h1 {
	font: 400 32px/1.1em Cardo, Georgia, serif;
	/*-webkit-font-smoothing: antialiased;*/
}

h3 {
	font: 700 25px/1.1em Cardo, Georgia, serif;
	/*-webkit-font-smoothing: antialiased;*/
}

div, p {
	font-family: Cardo, Georgia, serif;
	/*-webkit-font-smoothing: antialiased;*/
}

input[type=range] {
	-webkit-appearance: none;
	margin: 0px 0;
	width: 100%;
}

input[type=range]:focus {
	outline: none;
}

input[type=range]::-webkit-slider-runnable-track {
	width: 100%;
	height: 1px;
	cursor: pointer;
	animate: 0.2s;
	box-shadow: 0px 0px 0px #858585;
	background: #3071A9;
	border-radius: 0px;
	border: 1px solid #878787;
}

input[type=range]::-webkit-slider-thumb {
	box-shadow: 1px 1px 1px #000000;
	border: 1px solid #000000;
	height: 16px;
	width: 16px;
	border-radius: 16px;
	background: #FFFFFF;
	cursor: pointer;
	-webkit-appearance: none;
	margin-top: -8.5px;
}

input[type=range]:focus::-webkit-slider-runnable-track {
	background: #3071A9;
}

input[type=range]::-moz-range-track {
	width: 100%;
	height: 1px;
	cursor: pointer;
	animate: 0.2s;
	box-shadow: 0px 0px 0px #858585;
	background: #3071A9;
	border-radius: 0px;
	border: 1px solid #878787;
}

input[type=range]::-moz-range-thumb {
	box-shadow: 1px 1px 1px #000000;
	border: 1px solid #000000;
	height: 16px;
	width: 16px;
	border-radius: 16px;
	background: #FFFFFF;
	cursor: pointer;
}

input[type=range]::-ms-track {
	width: 100%;
	height: 1px;
	cursor: pointer;
	animate: 0.2s;
	background: transparent;
	border-color: transparent;
	color: transparent;
}

input[type=range]::-ms-fill-lower {
	background: #3071A9;
	border: 1px solid #878787;
	border-radius: 0px;
	box-shadow: 0px 0px 0px #858585;
}

input[type=range]::-ms-fill-upper {
	background: #3071A9;
	border: 1px solid #878787;
	border-radius: 0px;
	box-shadow: 0px 0px 0px #858585;
}

input[type=range]::-ms-thumb {
	box-shadow: 1px 1px 1px #000000;
	border: 1px solid #000000;
	height: 16px;
	width: 16px;
	border-radius: 16px;
	background: #FFFFFF;
	cursor: pointer;
}

input[type=range]:focus::-ms-fill-lower {
	background: #3071A9;
}

input[type=range]:focus::-ms-fill-upper {
	background: #3071A9;
}
</style>
</head>
<body>
	<div style="position: fixed; padding: 30px;" id="ui">
		<h1>Posterior sampling</h1>
		<p>
			<i>See Section 8.6 in ESL. Use Chrome!</i>
		</p>
		<p>
			3D using <a href="https://threejs.org/">three.js</a>.

		</p>
	</div>
	<div id="container"></div>
	<script src="js/three.js" type="text/javascript"></script>
	<script src="js/OrbitControls.js" type="text/javascript"></script>
	<script src="js/RGBELoader.js" type="text/javascript"></script>
	<script src="js/HDRCubeTextureLoader.js" type="text/javascript"></script>

	<script src="js/Detector.js" type="text/javascript"></script>
	<script src="js/stats.min.js" type="text/javascript"></script>

	<script src="js/Half.js" type="text/javascript"></script>
	<script src="js/Encodings.js" type="text/javascript"></script>
	<script src="js/PMREMGenerator.js" type="text/javascript"></script>
	<script src="js/PMREMCubeUVPacker.js" type="text/javascript"></script>
	<script src="js/dat.gui.min.js" type="text/javascript"></script>

	<script src="js/shaders/FilmShader.js" type="text/javascript"></script>
	<script src="js/shaders/VignetteShader.js" type="text/javascript"></script>

	<script src="js/postprocessing/EffectComposer.js"
		type="text/javascript"></script>
	<script src="js/postprocessing/RenderPass.js" type="text/javascript"></script>
	<script src="js/postprocessing/FilmPass.js" type="text/javascript"></script>
	<script src="js/postprocessing/MaskPass.js" type="text/javascript"></script>
	<script src="js/postprocessing/ShaderPass.js" type="text/javascript"></script>
	<script src="js/shaders/CopyShader.js" type="text/javascript"></script>
	<script src="js/shaders/FXAAShader.js" type="text/javascript"></script>
	<script src="js/shaders/ConvolutionShader.js" type="text/javascript"></script>
	<script src="js/shaders/LuminosityHighPassShader.js"
		type="text/javascript"></script>
	<script src="js/postprocessing/UnrealBloomPass.js"
		type="text/javascript"></script>

	<script type="text/javascript">
		var Settings = {};
		Settings.run = false;
		Settings.Sx = 34;
		Settings.Sy = 9;
		Settings.rho = 94;
		Settings.brokenImpl = false;

		var ui = document.getElementById('ui');

		var meshGeometry;

		function createSlider(container, name, label, defaultValue) {
			var html = "<div><span id='"+ name +"Label'>" + label + "&nbsp;&nbsp;</span>";
			html += "<input id='"+name+"Slider' value='"+defaultValue+ "' type='range' min='0' max='100' style='width: 300px;'>";
			html += "&nbsp;&nbsp;<span id='"+name+"Value'>" + defaultValue + "</span></div>";
			container.insertAdjacentHTML('beforeend', html);
			Settings[name] = defaultValue;

			var slider = document.getElementById(name + "Slider");
			var value = document.getElementById(name + "Value");
			slider.addEventListener('input', function() {
				Settings[name] = slider.value;
				value.innerHTML = slider.value;
				if (Settings.run) {
					Settings.run = false;
					updateParameters();
					Settings.run = true;
				}
				updateParameters();
			});
		}

		function run() {
			var link = document.getElementById("run");
			if (Settings.run) {
				link.innerHTML = "MCMC (Gibbs) Sample";
				Settings.run = false;
				scene.remove(sampleObject);
				sampleData = null;
			} else {
				link.innerHTML = "Stop";
				totalSamples = 0;
				Settings.run = true;
			}
			window.requestAnimationFrame(updateParameters);
		}

		ui.insertAdjacentHTML('beforeend', "<h3>Bivariate normal distribution</h3>");
		createSlider(ui, "Sx", "Sx", 34);
		createSlider(ui, "Sy", "Sy", 9);
		createSlider(ui, "rho", "Correlation (&rho;)", 34);

		ui.insertAdjacentHTML('beforeend', "<p></p><div><a class=toggle id=run href='javascript:run();' >MCMC (Gibbs) Sample</a> </div>");

		if (!Detector.webgl)
			Detector.addGetWebGLMessage();

		var terrainWidth = 128;
		var terrainDepth = 128;
		var terrainHalfWidth = terrainWidth / 2;
		var terrainHalfDepth = terrainDepth / 2;
		var terrainMaxHeight = 8;
		var terrainMinHeight = 0;

		// Graphics variables
		var terrainMesh, texture;
		var heightData = null;
		var sampleData = null;

		var container, stats;
		var params = {
			projection : 'normal',
			background : false,
			exposure : 1.0,
			bloomStrength : 1.5,
			bloomThreshold : 0.85,
			bloomRadius : 0.4,
			metalness: 0.0,
			brokenImpl: false
		};
		var camera, scene, renderer, controls;
		var effectFXAA, bloomPass, renderScene;
		var hdrCubeMap;
		var composer;
		var standardMaterial;
		var hdrCubeRenderTarget;

		var sampleGeometry;
		var marginal1 = null, marginal2 = null;
		var sampleBins = 60;
		var sampleObject = null;
		var globalMax = 0;
		init();
		animate();
		var totalSamples = 0;

		function sample() {
			var size = sampleBins * sampleBins;

			if (sampleData == null) {
				sampleData = new Float32Array(size);

				sampleGeometry = new THREE.PlaneBufferGeometry(100, 100, sampleBins - 1, sampleBins - 1);
				sampleGeometry.rotateX(-Math.PI / 2);

				var groundMaterial = new THREE.MeshPhongMaterial({
					specular : 0x101010,
					shininess : 230,
					color : 0xAAFFFF,
					side : THREE.DoubleSide,
					transparent : true,
					opacity : 0.5
				});

				var mat = new THREE.LineBasicMaterial({
					color : 0x888888,
					linewidth : 1,
					side : THREE.FrontSide
				});
				sampleObject = new THREE.Mesh(sampleGeometry, groundMaterial);
				sampleObject.translateY(1.0);
				sampleObject.receiveShadow = true;
				sampleObject.castShadow = true;

				scene.add(sampleObject);
			}

			var vertices = sampleGeometry.attributes.position.array;

			var s2 = sampleBins / 2;
			var p = 0;
			var max = 0;

			var x = 0;
			var y = 0;
			var sx = (Settings.Sx / 100);
			var sy = (Settings.Sy / 100);

			// Sample conditional distributions, see 
			// https://onlinecourses.science.psu.edu/stat414/node/118
			var rho = Settings.rho / 100;
			var samples = 10000;
			for (var i = 0; i < samples; i++) {
				var oldX = x;
				x = rnd.nextGaussian() * sx * Math.sqrt(1 - rho * rho) + rho * (sx / sy) * y;
				y = rnd.nextGaussian() * sy * Math.sqrt(1 - rho * rho) + rho * (sy / sx) * (Settings.brokenImpl ? oldX : x);
				if (Math.abs(x) > 1 || Math.abs(y) > 1)
					continue;
				var ind = sampleBins * Math.trunc(y * s2 + s2) + Math.trunc(x * s2 + s2);
				sampleData[ind] += 1;
				if (sampleData[ind] > max)
					max = sampleData[ind];
			}
			
			totalSamples += samples;
			var link = document.getElementById("run");
			link.innerHTML = "Stop (" + totalSamples/1000 +  "K samples on " + sampleBins + "&sup2; bins)";

			for (var i = 0, j = 0, l = vertices.length; i < l; i++, j += 3) {
				vertices[j + 1] = 1.0 + sampleData[i] * globalMax / max;
			}
			sampleGeometry.verticesNeedUpdate = true;
			sampleGeometry.normalsNeedUpdate = true;
			sampleGeometry.attributes.position.needsUpdate = true;
			sampleGeometry.computeVertexNormals();

		}

		function updateParameters() {
			if (Settings.run) {
				sample();
				window.requestAnimationFrame(updateParameters);
			} else {
				heightData = generateHeight(terrainWidth, terrainDepth, terrainMinHeight, terrainMaxHeight);
			}
			updateGeometry();

			scene.remove(marginal1);
			marginal1 = createMarginal(Settings.Sx / 100, true);
			scene.add(marginal1);
			scene.remove(marginal2);
			marginal2 = createMarginal(Settings.Sy / 100, false);
			scene.add(marginal2);

		}

		function updateGeometry() {
			var vertices = meshGeometry.attributes.position.array;
			for (var i = 0, j = 0, l = vertices.length; i < l; i++, j += 3) {
				vertices[j + 1] = heightData[i];
			}
			meshGeometry.verticesNeedUpdate = true;
			meshGeometry.normalsNeedUpdate = true;
			meshGeometry.attributes.position.needsUpdate = true;
			meshGeometry.computeVertexNormals();
		}

		function generateHeight(width, depth, minHeight, maxHeight) {
			var size = width * depth;
			var data = new Float32Array(size);

			var hRange = maxHeight - minHeight;
			var w2 = width / 2;
			var d2 = depth / 2;

			var p = 0;
			var sx = Settings.Sx / 100;
			var sy = Settings.Sy / 100;
			var V12 = 0.01;
			var rho = Settings.rho / 100; //V12/(sx*sy);
			var c = (1.0 / (2.0 * Math.PI * sx * sy * Math.sqrt(1 - rho * rho)));
			globalMax = 0;
			for (var j = 0; j < depth; j++) {
				for (var i = 0; i < width; i++) {
					var x = ((i) - w2) / w2;
					var y = ((j) - d2) / d2;
					// Bivariate normal distribution (see http://mathworld.wolfram.com/BivariateNormalDistribution.html)

					var z = x * x / (sx * sx) - 2 * rho * x * y / (sx * sy) + y * y / (sy * sy);
					var val = c * Math.exp(-z / (2.0 * (1.0 - rho * rho)));
					//if (x>0.5 || y>0.5) val = 0;
					data[p] = val * 10.0;
					if (globalMax < data[p])
						globalMax = data[p];
					p++;
				}
			}
			return data;
		}

		function init() {
			container = document.createElement('div');
			document.body.appendChild(container);

			camera = new THREE.PerspectiveCamera(20, window.innerWidth / window.innerHeight, 1, 2000);
			camera.position.set(0.0, 35, 35 * 3.5);

			scene = new THREE.Scene();

			renderer = new THREE.WebGLRenderer({
				antialias : false
			});
			renderer.setClearColor(new THREE.Color(0x222222));
			renderer.toneMapping = THREE.LinearToneMapping;

			standardMaterial = new THREE.MeshStandardMaterial({
				map : null,
				color : 0xffffff,
				metalness : 0.00,
				side : THREE.DoubleSide,
				shading : THREE.SmoothShading
			//,transparent: true,
			//opacity: 0.5
			});

			heightData = generateHeight(terrainWidth, terrainDepth, terrainMinHeight, terrainMaxHeight);

			var geometry = new THREE.PlaneBufferGeometry(100, 100, terrainWidth - 1, terrainDepth - 1);
			geometry.rotateX(-Math.PI / 2);
			meshGeometry = geometry;

			updateGeometry();

			terrainMesh = new THREE.Mesh(geometry, standardMaterial);
			terrainMesh.receiveShadow = true;
			terrainMesh.castShadow = true;

			scene.add(terrainMesh);

			var textureLoader = new THREE.TextureLoader();
			textureLoader.load("./js/roughness_map3.jpg", function(map) {
				map.wrapS = THREE.RepeatWrapping;
				map.wrapT = THREE.RepeatWrapping;
				map.anisotropy = 4;
				map.repeat.set(1, 1);
				standardMaterial.roughnessMap = map;
				standardMaterial.bumpMap = map;
				standardMaterial.needsUpdate = true;
			});

			var genCubeUrls = function(prefix, postfix) {
				return [ prefix + 'px' + postfix, prefix + 'nx' + postfix, prefix + 'py' + postfix, prefix + 'ny' + postfix,
						prefix + 'pz' + postfix, prefix + 'nz' + postfix ];
			};

			var hdrUrls = genCubeUrls("./js/cube/pisaHDR/", ".hdr");
			new THREE.HDRCubeTextureLoader().load(THREE.UnsignedByteType, hdrUrls, function(hdrCubeMap) {

				var pmremGenerator = new THREE.PMREMGenerator(hdrCubeMap);
				pmremGenerator.update(renderer);

				var pmremCubeUVPacker = new THREE.PMREMCubeUVPacker(pmremGenerator.cubeLods);
				pmremCubeUVPacker.update(renderer);

				hdrCubeRenderTarget = pmremCubeUVPacker.CubeUVRenderTarget;

			});

			// Lights

			scene.add(new THREE.AmbientLight(0x222222));

			var spotLight = new THREE.SpotLight(0xffffff);
			spotLight.position.set(50, 100, 50);
			spotLight.angle = Math.PI / 7;
			spotLight.penumbra = 0.8
			spotLight.castShadow = true;
			scene.add(spotLight);

			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.shadowMap.enabled = true;
			container.appendChild(renderer.domElement);

			renderScene = new THREE.RenderPass(scene, camera);

			// renderScene.clear = true;
			effectFXAA = new THREE.ShaderPass(THREE.FXAAShader);
			effectFXAA.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);

			var copyShader = new THREE.ShaderPass(THREE.CopyShader);
			copyShader.renderToScreen = true;

			var shaderVignette = THREE.VignetteShader;
			var effectVignette = new THREE.ShaderPass(shaderVignette);
			effectVignette.uniforms["offset"].value = 0.95;
			effectVignette.uniforms["darkness"].value = 2.0;
			var effectFilm = new THREE.FilmPass(0.55, 0.525, 1048, false);

			bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);//1.0, 9, 0.5, 512);
			composer = new THREE.EffectComposer(renderer);
			composer.setSize(window.innerWidth, window.innerHeight);
			composer.addPass(renderScene);
			composer.addPass(effectFXAA);
			composer.addPass(bloomPass);
			composer.addPass(effectVignette);
			//	composer.addPass(effectFilm);
			composer.addPass(copyShader);
			renderer.toneMapping = THREE.ReinhardToneMapping;
			renderer.gammaInput = true;
			renderer.gammaOutput = true;

			stats = new Stats();
			container.appendChild(stats.dom);

			controls = new THREE.OrbitControls(camera, renderer.domElement);
			controls.update();

			window.addEventListener('resize', onWindowResize, false);

			var gui = new dat.GUI();

			gui.add(params, 'exposure', 0.1, 2);
			gui.add(params, 'bloomThreshold', 0.0, 1.0).onChange(function(value) {
				bloomPass.threshold = Number(value);
			});
			gui.add(params, 'bloomStrength', 0.0, 3.0).onChange(function(value) {
				bloomPass.strength = Number(value);
			});
			gui.add(params, 'bloomRadius', 0.0, 1.0).onChange(function(value) {
				bloomPass.radius = Number(value);
			});
			gui.add(params, 'metalness', 0.0, 1.0).onChange(function(value) {
				if (terrainMesh.material !== undefined) 
					terrainMesh.material.metalness = Number(value);
			});
			gui.add(params, 'brokenImpl').onChange(function(value) {
				Settings.brokenImpl = value;
			});
			gui.open();

		}

		function createMarginal(sx, isX) {
			var s = new THREE.Shape();
			for (var j = 0; j < 400; j++) {
				var x = (j - 200) / 100;
				var y = Math.exp(-x * x / (sx * sx * 2)) / (sx * Math.sqrt(Math.PI * 2.0));
				if (j == 0)
					s.moveTo(x * 50, y * 10);
				s.lineTo(x * 50, y * 10);
			}
			var geometry = new THREE.ShapeGeometry(s);
			var material2 = new THREE.MeshLambertMaterial({
				color : isX ? 0x6666ff : 0xff6666,
				transparent : true,
				opacity : 0.9,
				side : THREE.DoubleSide
			});
			var mesh = new THREE.Mesh(geometry, material2 /*new THREE.MeshPhongMaterial()*/);
			if (isX) {
				mesh.translateZ(-50);
			} else {
				mesh.rotateY(Math.PI / 2);
				mesh.translateZ(-50);
			}
			mesh.receiveShadow = true;
			return mesh;
		}

		function onWindowResize() {
			var width = window.innerWidth;
			var height = window.innerHeight;

			camera.aspect = width / height;
			camera.updateProjectionMatrix();

			renderer.setSize(width, height);
			composer.setSize(width, height);
			effectFXAA.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
		}

		function animate() {
			requestAnimationFrame(animate);
			stats.begin();
			render();
			stats.end();
		}

		function render() {
			controls.update(0.01);

			if (standardMaterial !== undefined) {
				standardMaterial.roughness = 1.0;
				standardMaterial.bumpScale = -0.05;
				var newEnvMap = standardMaterial.envMap;
				newEnvMap = hdrCubeRenderTarget ? hdrCubeRenderTarget.texture : null;
				if (newEnvMap !== standardMaterial.envMap) {
					standardMaterial.envMap = newEnvMap;
					standardMaterial.needsUpdate = true;
				}
			}
			renderer.toneMappingExposure = Math.pow(params.exposure, 4.0);
			var timer = Date.now() * 0.00025;
			camera.lookAt(scene.position);
			composer.render(0.01);
		}

		// -------------------------------------------------------------------------------------------------------------
		// Normal distribution using Ziggurat method. Taken from:
		// https://www.filosophy.org/post/35/normaldistributed_random_values_in_javascript_using_the_ziggurat_algorithm/
		// -------------------------------------------------------------------------------------------------------------

		function Ziggurat() {

			var jsr = 123456789;

			var wn = Array(128);
			var fn = Array(128);
			var kn = Array(128);

			function RNOR() {
				var hz = SHR3();
				var iz = hz & 127;
				return (Math.abs(hz) < kn[iz]) ? hz * wn[iz] : nfix(hz, iz);
			}

			this.nextGaussian = function() {
				return RNOR();
			}

			function nfix(hz, iz) {
				var r = 3.442619855899;
				var r1 = 1.0 / r;
				var x;
				var y;
				while (true) {
					x = hz * wn[iz];
					if (iz == 0) {
						x = (-Math.log(UNI()) * r1);
						y = -Math.log(UNI());
						while (y + y < x * x) {
							x = (-Math.log(UNI()) * r1);
							y = -Math.log(UNI());
						}
						return (hz > 0) ? r + x : -r - x;
					}

					if (fn[iz] + UNI() * (fn[iz - 1] - fn[iz]) < Math.exp(-0.5 * x * x)) {
						return x;
					}
					hz = SHR3();
					iz = hz & 127;

					if (Math.abs(hz) < kn[iz]) {
						return (hz * wn[iz]);
					}
				}
			}

			function SHR3() {
				var jz = jsr;
				var jzr = jsr;
				jzr ^= (jzr << 13);
				jzr ^= (jzr >>> 17);
				jzr ^= (jzr << 5);
				jsr = jzr;
				return (jz + jzr) | 0;
			}

			function UNI() {
				return 0.5 * (1 + SHR3() / -Math.pow(2, 31));
			}

			function zigset() {
				// seed generator based on current time
				jsr ^= new Date().getTime();

				var m1 = 2147483648.0;
				var dn = 3.442619855899;
				var tn = dn;
				var vn = 9.91256303526217e-3;

				var q = vn / Math.exp(-0.5 * dn * dn);
				kn[0] = Math.floor((dn / q) * m1);
				kn[1] = 0;

				wn[0] = q / m1;
				wn[127] = dn / m1;

				fn[0] = 1.0;
				fn[127] = Math.exp(-0.5 * dn * dn);

				for (var i = 126; i >= 1; i--) {
					dn = Math.sqrt(-2.0 * Math.log(vn / dn + Math.exp(-0.5 * dn * dn)));
					kn[i + 1] = Math.floor((dn / tn) * m1);
					tn = dn;
					fn[i] = Math.exp(-0.5 * dn * dn);
					wn[i] = dn / m1;
				}
			}
			zigset();
		}

		var rnd = new Ziggurat();
	</script>

</body>
</html>
