<!--
Notice: this file contains code from other authors which may be covered by other copyrights:
1) The Ziggurat Normal Distribution is taken from https://www.filosophy.org/post/35/normaldistributed_random_values_in_javascript_using_the_ziggurat_algorithm/
//-->
<html>
<head>
<link
	href="https://fonts.googleapis.com/css?family=Cardo|Open+Sans:400,400i,600|Material+Icons"
	rel="stylesheet">
<script type="text/javascript"
	src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>
<style type="text/css">
html, body {
	padding: 0px;
	font: 750 32px/1.5em Cardo, Georgia, serif;
	color: white;
	font-size: 21px;
}

/* Bret Victor style 'Tangle' inspired links (http://worrydream.com/Tangle/) */
a:hover {
	color: #00f;
	border-color: #00f;
	text-decoration: none;
}

a {
	border-bottom: 3px dotted #99f;
	padding: 0px 1px;
	cursor: pointer;
	text-decoration: none;
}

/* The modal text box is based on code from: http://www.w3schools.com/howto/howto_css_modals.asp */

/* The Modal (background) */
.modal {
	display: none; /* Hidden by default */
	position: fixed; /* Stay in place */
	z-index: 1; /* Sit on top */
	padding-top: 100px; /* Location of the box */
	left: 0;
	top: 0;
	width: 100%; /* Full width */
	height: 100%; /* Full height */
	overflow: auto; /* Enable scroll if needed */
	background-color: rgb(0, 0, 0); /* Fallback color */
	background-color: rgba(0, 0, 0, 0.4); /* Black w/ opacity */
}

/* Modal Content */
.modal-content {
	background-color: #fefefe;
	margin: auto;
	padding: 20px;
	border: 1px solid #888;
	width: 80%;
}

/* ------------------------------------------------------------------------------------------------------------------- */
/* all of this style code just styles the input slider (autogenerated from http://www.cssportal.com/style-input-range/) */
h1 {
	font: 400 32px/1.1em Cardo, Georgia, serif;
	/*-webkit-font-smoothing: antialiased;*/
}

h3 {
	font: 700 25px/1.1em Cardo, Georgia, serif;
	/*-webkit-font-smoothing: antialiased;*/
}

div, p {
	font-family: Cardo, Georgia, serif;
	/*-webkit-font-smoothing: antialiased;*/
}

input[type=range] {
	-webkit-appearance: none;
	margin: 0px 0;
	width: 100%;
}

input[type=range]:focus {
	outline: none;
}

input[type=range]::-webkit-slider-runnable-track {
	width: 100%;
	height: 1px;
	cursor: pointer;
	animate: 0.2s;
	box-shadow: 0px 0px 0px #858585;
	background: #3071A9;
	border-radius: 0px;
	border: 1px solid #878787;
}

input[type=range]::-webkit-slider-thumb {
	box-shadow: 1px 1px 1px #000000;
	border: 1px solid #000000;
	height: 16px;
	width: 16px;
	border-radius: 16px;
	background: #FFFFFF;
	cursor: pointer;
	-webkit-appearance: none;
	margin-top: -8.5px;
}

input[type=range]:focus::-webkit-slider-runnable-track {
	background: #3071A9;
}

input[type=range]::-moz-range-track {
	width: 100%;
	height: 1px;
	cursor: pointer;
	animate: 0.2s;
	box-shadow: 0px 0px 0px #858585;
	background: #3071A9;
	border-radius: 0px;
	border: 1px solid #878787;
}

input[type=range]::-moz-range-thumb {
	box-shadow: 1px 1px 1px #000000;
	border: 1px solid #000000;
	height: 16px;
	width: 16px;
	border-radius: 16px;
	background: #FFFFFF;
	cursor: pointer;
}

input[type=range]::-ms-track {
	width: 100%;
	height: 1px;
	cursor: pointer;
	animate: 0.2s;
	background: transparent;
	border-color: transparent;
	color: transparent;
}

input[type=range]::-ms-fill-lower {
	background: #3071A9;
	border: 1px solid #878787;
	border-radius: 0px;
	box-shadow: 0px 0px 0px #858585;
}

input[type=range]::-ms-fill-upper {
	background: #3071A9;
	border: 1px solid #878787;
	border-radius: 0px;
	box-shadow: 0px 0px 0px #858585;
}

input[type=range]::-ms-thumb {
	box-shadow: 1px 1px 1px #000000;
	border: 1px solid #000000;
	height: 16px;
	width: 16px;
	border-radius: 16px;
	background: #FFFFFF;
	cursor: pointer;
}

input[type=range]:focus::-ms-fill-lower {
	background: #3071A9;
}

input[type=range]:focus::-ms-fill-upper {
	background: #3071A9;
}
</style>
</head>
<body>
	<div style="position: fixed; padding: 30px;" id="ui">
		<h1>Posterior sampling</h1>
		<p>
			<i>See Section 5.8 in ESL. Use Chrome!</i>
		</p>
		<p>
			<i>3D using <a href="https://threejs.org/">three.js</a> (based on Bloom example)</i>
		</p>
	</div>
	<div id="container"></div>
	<script src="js/three.js" type="text/javascript"></script>
	<script src="js/OrbitControls.js" type="text/javascript"></script>
	<script src="js/RGBELoader.js" type="text/javascript"></script>
	<script src="js/HDRCubeTextureLoader.js" type="text/javascript"></script>

	<script src="js/Detector.js" type="text/javascript"></script>
	<script src="js/stats.min.js" type="text/javascript"></script>

	<script src="js/Half.js" type="text/javascript"></script>
	<script src="js/Encodings.js" type="text/javascript"></script>
	<script src="js/PMREMGenerator.js" type="text/javascript"></script>
	<script src="js/PMREMCubeUVPacker.js" type="text/javascript"></script>
	<script src="js/dat.gui.min.js" type="text/javascript"></script>

	<script src="js/shaders/FilmShader.js" type="text/javascript"></script>
	<script src="js/shaders/VignetteShader.js" type="text/javascript"></script>

	<script src="js/postprocessing/EffectComposer.js" type="text/javascript"></script>
	<script src="js/postprocessing/RenderPass.js" type="text/javascript"></script>
	<script src="js/postprocessing/FilmPass.js" type="text/javascript"></script>
	<script src="js/postprocessing/MaskPass.js" type="text/javascript"></script>
	<script src="js/postprocessing/ShaderPass.js" type="text/javascript"></script>
	<script src="js/shaders/CopyShader.js" type="text/javascript"></script>
	<script src="js/shaders/FXAAShader.js" type="text/javascript"></script>
	<script src="js/shaders/ConvolutionShader.js" type="text/javascript"></script>
	<script src="js/shaders/LuminosityHighPassShader.js" type="text/javascript"></script>
	<script src="js/postprocessing/UnrealBloomPass.js" type="text/javascript"></script>

	<script type="text/javascript">
		var Settings = {};
		Settings.run = false;
		Settings.Sx = 34;
		Settings.Sy = 9;
		Settings.rho = 94;

		var ui = document.getElementById('ui');

		var meshGeometry;

		function createSlider(container, name, label, defaultValue) {
			var html = "<div><span id='"+ name +"Label'>" + label + "&nbsp;&nbsp;</span>";
			html += "<input id='"+name+"Slider' value='"+defaultValue+ "' type='range' min='0' max='100' style='width: 300px;'>";
			html += "&nbsp;&nbsp;<span id='"+name+"Value'>" + defaultValue + "</span></div>";
			container.insertAdjacentHTML('beforeend', html);
			Settings[name] = defaultValue;

			var slider = document.getElementById(name + "Slider");
			var value = document.getElementById(name + "Value");
			slider.addEventListener('input', function() {
				Settings[name] = slider.value;
				value.innerHTML = slider.value;
				if (Settings.run) {
					Settings.run = false;
					updateParameters();
					Settings.run = true;
				}
				updateParameters();
			});
		}

		function run() {
			var link = document.getElementById("run");
			if (Settings.run) {
				link.innerHTML = "Sample";
				Settings.run = false;
			} else {
				link.innerHTML = "Stop";
				Settings.run = true;
			}
			window.requestAnimationFrame(updateParameters);
		}

		ui.insertAdjacentHTML('beforeend', "<h3>Bivariate normal distribution</h3>");
		createSlider(ui, "Sx", "Sx", 34);
		createSlider(ui, "Sy", "Sy", 9);
		createSlider(ui, "rho", "Correlation (&#955;)", 34);

		ui.insertAdjacentHTML('beforeend', "<div><a class=toggle id=run href='javascript:run();' >Sample</a> </div>");

		if (!Detector.webgl)
			Detector.addGetWebGLMessage();

		var terrainWidth = 128;
		var terrainDepth = 128;
		var terrainHalfWidth = terrainWidth / 2;
		var terrainHalfDepth = terrainDepth / 2;
		var terrainMaxHeight = 8;
		var terrainMinHeight = 0;

		// Graphics variables
		var terrainMesh, texture;
		var heightData = null;

		var container, stats;
		var params = {
			projection : 'normal',
			background : false,
			exposure : 1.0,
			bloomStrength : 1.5,
			bloomThreshold : 0.85,
			bloomRadius : 0.4
		};
		var camera, scene, renderer, controls;
		var effectFXAA, bloomPass, renderScene;
		var hdrCubeMap;
		var composer;
		var standardMaterial;
		var hdrCubeRenderTarget;

		var marginal1 = null, marginal2 = null;
		
		init();
		animate();

		function updateParameters() {
			if (Settings.run) {
				var size = terrainWidth * terrainDepth;
				for (var i = 0; i < size; i++) {
					heightData[i] += (Math.random() - 0.5) * 0.1;
				}
				window.requestAnimationFrame(updateParameters);
			} else {
				heightData = generateHeight(terrainWidth, terrainDepth, terrainMinHeight, terrainMaxHeight);
			}
			updateGeometry();
			
			scene.remove(marginal1);
			marginal1 = createMarginal(Settings.Sx/100, true);
			scene.add(marginal1);
			 scene.remove(marginal2);
			marginal2 = createMarginal(Settings.Sy/100, false);
			scene.add(marginal2);
			
		}

		function updateGeometry() {
			var vertices = meshGeometry.attributes.position.array;
			for (var i = 0, j = 0, l = vertices.length; i < l; i++, j += 3) {
				vertices[j + 1] = heightData[i];
			}
			meshGeometry.verticesNeedUpdate = true;
			meshGeometry.normalsNeedUpdate = true;
			meshGeometry.attributes.position.needsUpdate = true;
			meshGeometry.computeVertexNormals();
		}

		function generateHeight(width, depth, minHeight, maxHeight) {
			var size = width * depth;
			var data = new Float32Array(size);

			var hRange = maxHeight - minHeight;
			var w2 = width / 2;
			var d2 = depth / 2;

			var p = 0;
			var sx = Settings.Sx / 100;
			var sy = Settings.Sy / 100;
			var V12 = 0.01;
			var rho = Settings.rho / 100; //V12/(sx*sy);
			var c = (1.0 / (2.0 * Math.PI * sx * sy * Math.sqrt(1 - rho * rho)));
			for (var j = 0; j < depth; j++) {
				for (var i = 0; i < width; i++) {
					var x = ((i) - w2) / w2;
					var y = ((j) - d2) / d2;
					// Bivariate normal distribution (see http://mathworld.wolfram.com/BivariateNormalDistribution.html)

					var z = x * x / (sx * sx) - 2 * rho * x * y / (sx * sy) + y * y / (sy * sy);
					var val = c * Math.exp(-z / (2.0 * (1.0 - rho * rho)));
					//if (x>0.5 || y>0.5) val = 0;
					data[p] = val * 10.0;
					p++;
				}
			}
			return data;
		}

		function init() {
			container = document.createElement('div');
			document.body.appendChild(container);

			camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 2000);
			camera.position.set(0.0, 35, 35 * 3.5);

			scene = new THREE.Scene();

			renderer = new THREE.WebGLRenderer({
				antialias : false
			});
			renderer.setClearColor(new THREE.Color(0x222222));
			renderer.toneMapping = THREE.LinearToneMapping;

			standardMaterial = new THREE.MeshStandardMaterial({
				map : null,
				color : 0xffffff,
				metalness : 0.0,
				side : THREE.DoubleSide,
				shading : THREE.SmoothShading
			});

			heightData = generateHeight(terrainWidth, terrainDepth, terrainMinHeight, terrainMaxHeight);

			var geometry = new THREE.PlaneBufferGeometry(100, 100, terrainWidth - 1, terrainDepth - 1);
			geometry.rotateX(-Math.PI / 2);
			meshGeometry = geometry;

			updateGeometry();

			var groundMaterial = new THREE.MeshPhongMaterial({
				specular : 0x101010,
				shininess : 230,
				color : 0xAAFFFF,
				side : THREE.DoubleSide
			});

			var geo = new THREE.WireframeGeometry(geometry); // or WireframeGeometry( geometry )

			var mat = new THREE.LineBasicMaterial({
				color : 0x888888,
				linewidth : 1,
				side : THREE.FrontSide
			});

			var wireframe = new THREE.LineSegments(geo, mat);

			terrainMesh = new THREE.Mesh(geometry, standardMaterial);
			terrainMesh.receiveShadow = true;
			terrainMesh.castShadow = true;
			wireframe.translateY(1.0);
			wireframe.receiveShadow = true;
			wireframe.castShadow = true;

			scene.add(terrainMesh);
			//scene.add( wireframe );

			
			var textureLoader = new THREE.TextureLoader();
			textureLoader.load("./js/roughness_map3.jpg", function(map) {
				map.wrapS = THREE.RepeatWrapping;
				map.wrapT = THREE.RepeatWrapping;
				map.anisotropy = 4;
				map.repeat.set(1, 1);
				standardMaterial.roughnessMap = map;
				standardMaterial.bumpMap = map;
				standardMaterial.needsUpdate = true;
			});

			var genCubeUrls = function(prefix, postfix) {
				return [ prefix + 'px' + postfix, prefix + 'nx' + postfix, prefix + 'py' + postfix, prefix + 'ny' + postfix,
						prefix + 'pz' + postfix, prefix + 'nz' + postfix ];
			};

			var hdrUrls = genCubeUrls("./js/cube/pisaHDR/", ".hdr");
			new THREE.HDRCubeTextureLoader().load(THREE.UnsignedByteType, hdrUrls, function(hdrCubeMap) {

				var pmremGenerator = new THREE.PMREMGenerator(hdrCubeMap);
				pmremGenerator.update(renderer);

				var pmremCubeUVPacker = new THREE.PMREMCubeUVPacker(pmremGenerator.cubeLods);
				pmremCubeUVPacker.update(renderer);

				hdrCubeRenderTarget = pmremCubeUVPacker.CubeUVRenderTarget;

			});

			// Lights

			scene.add(new THREE.AmbientLight(0x222222));

			var spotLight = new THREE.SpotLight(0xffffff);
			spotLight.position.set(50, 100, 50);
			spotLight.angle = Math.PI / 7;
			spotLight.penumbra = 0.8
			spotLight.castShadow = true;
			scene.add(spotLight);

			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.shadowMap.enabled = true;
			container.appendChild(renderer.domElement);

			renderScene = new THREE.RenderPass(scene, camera);

			// renderScene.clear = true;
			effectFXAA = new THREE.ShaderPass(THREE.FXAAShader);
			effectFXAA.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);

			var copyShader = new THREE.ShaderPass(THREE.CopyShader);
			copyShader.renderToScreen = true;

			var shaderVignette = THREE.VignetteShader;
			var effectVignette = new THREE.ShaderPass(shaderVignette);
			effectVignette.uniforms["offset"].value = 0.95;
			effectVignette.uniforms["darkness"].value = 2.0;
			var effectFilm = new THREE.FilmPass(0.55, 0.525, 1048, false);

			bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);//1.0, 9, 0.5, 512);
			composer = new THREE.EffectComposer(renderer);
			composer.setSize(window.innerWidth, window.innerHeight);
			composer.addPass(renderScene);
			composer.addPass(effectFXAA);
			composer.addPass(bloomPass);
			composer.addPass(effectVignette);
			//	composer.addPass(effectFilm);
			composer.addPass(copyShader);
			renderer.toneMapping = THREE.ReinhardToneMapping;
			renderer.gammaInput = true;
			renderer.gammaOutput = true;

			stats = new Stats();
			container.appendChild(stats.dom);

			controls = new THREE.OrbitControls(camera, renderer.domElement);
			controls.update();

			window.addEventListener('resize', onWindowResize, false);

			var gui = new dat.GUI();

			gui.add(params, 'exposure', 0.1, 2);
			gui.add(params, 'bloomThreshold', 0.0, 1.0).onChange(function(value) {
				bloomPass.threshold = Number(value);
			});
			gui.add(params, 'bloomStrength', 0.0, 3.0).onChange(function(value) {
				bloomPass.strength = Number(value);
			});
			gui.add(params, 'bloomRadius', 0.0, 1.0).onChange(function(value) {
				bloomPass.radius = Number(value);
			});
			gui.open();

		}

		
		function createMarginal(sx, isX) {
			var s = new THREE.Shape();
			for (var j = 0; j < 400; j++) {
				var x = (j-200) / 100; 
				var y = Math.exp(-x*x/(sx*sx*2)) / (sx*Math.sqrt(Math.PI*2.0));
				if (j == 0) s. moveTo(x * 50, y * 10);
				s.lineTo(x * 50, y * 10);
			}
			var geometry = new THREE.ShapeGeometry(s);
			var material2 = new THREE.MeshLambertMaterial({
				color : isX ? 0x6666ff : 0xff6666,
				transparent : true,
				opacity : 0.7,
				side : THREE.DoubleSide
			});
			var mesh = new THREE.Mesh(geometry, material2 /*new THREE.MeshPhongMaterial()*/);
			if (isX) {
				mesh.translateZ(-50);
			} else {
				mesh.rotateY(Math.PI/2);
				mesh.translateZ(-50);
			}
			mesh.receiveShadow = true;
			return mesh;
		}
		
		function onWindowResize() {
			var width = window.innerWidth;
			var height = window.innerHeight;

			camera.aspect = width / height;
			camera.updateProjectionMatrix();

			renderer.setSize(width, height);
			composer.setSize(width, height);
			effectFXAA.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
		}

		function animate() {
			requestAnimationFrame(animate);
			stats.begin();
			render();
			stats.end();
		}

		function render() {
			controls.update(0.01);

			if (standardMaterial !== undefined) {
				standardMaterial.roughness = 1.0;
				standardMaterial.bumpScale = -0.05;
				var newEnvMap = standardMaterial.envMap;
				newEnvMap = hdrCubeRenderTarget ? hdrCubeRenderTarget.texture : null;
				if (newEnvMap !== standardMaterial.envMap) {
					standardMaterial.envMap = newEnvMap;
					standardMaterial.needsUpdate = true;
				}
			}
			renderer.toneMappingExposure = Math.pow(params.exposure, 4.0);
			var timer = Date.now() * 0.00025;
			camera.lookAt(scene.position);
			composer.render(0.01);
		}
	</script>

</body>
</html>
