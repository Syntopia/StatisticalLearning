<!--
Notice: this file contains code from other authors which may be covered by other copyrights:
1) The Ziggurat Normal Distribution is taken from https://www.filosophy.org/post/35/normaldistributed_random_values_in_javascript_using_the_ziggurat_algorithm/
//-->
<html>
<head>
<link
	href="https://fonts.googleapis.com/css?family=Cardo|Open+Sans:400,400i,600|Material+Icons"
	rel="stylesheet">
<script type="text/javascript"
	src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>
<style type="text/css">
html, body {
	padding: 0px;
	font: 750 32px/1.5em Cardo, Georgia, serif;
	color: white;
	font-size: 21px;
	 margin: 0px;
  overflow: hidden;
}

/* Bret Victor style 'Tangle' inspired links (http://worrydream.com/Tangle/) */
a:hover {
	color: #ddf;
	border-color: #ddf;
	text-decoration: none;
}

a {
	font-family: Cardo, Georgia, serif;
	color: #ddf;
	border-bottom: 3px dotted #ddf;
	padding: 0px 1px;
	cursor: pointer;
	text-decoration: none;
}

/* The modal text box is based on code from: http://www.w3schools.com/howto/howto_css_modals.asp */

/* The Modal (background) */
.modal {
	display: none; /* Hidden by default */
	position: fixed; /* Stay in place */
	z-index: 1; /* Sit on top */
	padding-top: 100px; /* Location of the box */
	left: 0;
	top: 0;
	width: 100%; /* Full width */
	height: 100%; /* Full height */
	overflow: auto; /* Enable scroll if needed */
	background-color: rgb(0, 0, 0); /* Fallback color */
	background-color: rgba(0, 0, 0, 0.4); /* Black w/ opacity */
}

/* Modal Content */
.modal-content {
	background-color: #fefefe;
	margin: auto;
	padding: 20px;
	border: 1px solid #888;
	width: 80%;
}

/* ------------------------------------------------------------------------------------------------------------------- */
/* all of this style code just styles the input slider (autogenerated from http://www.cssportal.com/style-input-range/) */
h1 {
	font: 400 32px/1.1em Cardo, Georgia, serif;
	/*-webkit-font-smoothing: antialiased;*/
}

h3 {
	font: 700 25px/1.1em Cardo, Georgia, serif;
	/*-webkit-font-smoothing: antialiased;*/
}

div, p {
	font-family: Cardo, Georgia, serif;
	/*-webkit-font-smoothing: antialiased;*/
}

input[type=range] {
	-webkit-appearance: none;
	margin: 0px 0;
	width: 100%;
}

input[type=range]:focus {
	outline: none;
}

input[type=range]::-webkit-slider-runnable-track {
	width: 100%;
	height: 1px;
	cursor: pointer;
	animate: 0.2s;
	box-shadow: 0px 0px 0px #858585;
	background: #3071A9;
	border-radius: 0px;
	border: 1px solid #878787;
}

input[type=range]::-webkit-slider-thumb {
	box-shadow: 1px 1px 1px #000000;
	border: 1px solid #000000;
	height: 16px;
	width: 16px;
	border-radius: 16px;
	background: #FFFFFF;
	cursor: pointer;
	-webkit-appearance: none;
	margin-top: -8.5px;
}

input[type=range]:focus::-webkit-slider-runnable-track {
	background: #3071A9;
}

input[type=range]::-moz-range-track {
	width: 100%;
	height: 1px;
	cursor: pointer;
	animate: 0.2s;
	box-shadow: 0px 0px 0px #858585;
	background: #3071A9;
	border-radius: 0px;
	border: 1px solid #878787;
}

input[type=range]::-moz-range-thumb {
	box-shadow: 1px 1px 1px #000000;
	border: 1px solid #000000;
	height: 16px;
	width: 16px;
	border-radius: 16px;
	background: #FFFFFF;
	cursor: pointer;
}

input[type=range]::-ms-track {
	width: 100%;
	height: 1px;
	cursor: pointer;
	animate: 0.2s;
	background: transparent;
	border-color: transparent;
	color: transparent;
}

input[type=range]::-ms-fill-lower {
	background: #3071A9;
	border: 1px solid #878787;
	border-radius: 0px;
	box-shadow: 0px 0px 0px #858585;
}

input[type=range]::-ms-fill-upper {
	background: #3071A9;
	border: 1px solid #878787;
	border-radius: 0px;
	box-shadow: 0px 0px 0px #858585;
}

input[type=range]::-ms-thumb {
	box-shadow: 1px 1px 1px #000000;
	border: 1px solid #000000;
	height: 16px;
	width: 16px;
	border-radius: 16px;
	background: #FFFFFF;
	cursor: pointer;
}

input[type=range]:focus::-ms-fill-lower {
	background: #3071A9;
}

input[type=range]:focus::-ms-fill-upper {
	background: #3071A9;
}
</style>
</head>
<body>
	<div style="position: fixed; padding: 30px;" id="ui">
		<h1>Suuport Vector Machines</h1>
		<p>
			<i></i>
		</p>
		<p>
			3D using <a href="https://threejs.org/">three.js</a>.

		</p>
	</div>
	<div id="container"></div>
	<script src="js/three.js" type="text/javascript"></script>
	<script src="js/OrbitControls.js" type="text/javascript"></script>
	<script src="js/RGBELoader.js" type="text/javascript"></script>
	<script src="js/HDRCubeTextureLoader.js" type="text/javascript"></script>

	<script src="js/Detector.js" type="text/javascript"></script>
	<script src="js/stats.min.js" type="text/javascript"></script>

	<script src="js/Half.js" type="text/javascript"></script>
	<script src="js/Encodings.js" type="text/javascript"></script>
	<script src="js/PMREMGenerator.js" type="text/javascript"></script>
	<script src="js/PMREMCubeUVPacker.js" type="text/javascript"></script>
	<script src="js/dat.gui.min.js" type="text/javascript"></script>

	<script src="js/shaders/FilmShader.js" type="text/javascript"></script>
	<script src="js/shaders/VignetteShader.js" type="text/javascript"></script>

	<script src="js/postprocessing/EffectComposer.js"
		type="text/javascript"></script>
	<script src="js/postprocessing/RenderPass.js" type="text/javascript"></script>
	<script src="js/postprocessing/FilmPass.js" type="text/javascript"></script>
	<script src="js/postprocessing/MaskPass.js" type="text/javascript"></script>
	<script src="js/postprocessing/ShaderPass.js" type="text/javascript"></script>
	<script src="js/shaders/CopyShader.js" type="text/javascript"></script>
	<script src="js/shaders/FXAAShader.js" type="text/javascript"></script>
	<script src="js/shaders/SSAOShader.js"></script>
		
	<script src="js/shaders/ConvolutionShader.js" type="text/javascript"></script>
	<script src="js/shaders/LuminosityHighPassShader.js"
		type="text/javascript"></script>
	<script src="js/postprocessing/UnrealBloomPass.js"
		type="text/javascript"></script>

	<script type="text/javascript">
		var Settings = {};
		
		Settings.points = [];
		Settings.gaussians = [];
		Settings.numberOfGaussians = 4;
		Settings.numberOfPoints = 50;
		Settings.gaussianDeviation = 2;
		
		var ui = document.getElementById('ui');

		var meshGeometry;

		// -------------------------------------------------------------------------------------------------------------
		// Normal distribution using Ziggurat method. Taken from:
		// https://www.filosophy.org/post/35/normaldistributed_random_values_in_javascript_using_the_ziggurat_algorithm/
		// -------------------------------------------------------------------------------------------------------------

		function Ziggurat() {

			var jsr = 123456789;

			var wn = Array(128);
			var fn = Array(128);
			var kn = Array(128);

			function RNOR() {
				var hz = SHR3();
				var iz = hz & 127;
				return (Math.abs(hz) < kn[iz]) ? hz * wn[iz] : nfix(hz, iz);
			}

			this.nextGaussian = function() {
				return RNOR();
			}

			function nfix(hz, iz) {
				var r = 3.442619855899;
				var r1 = 1.0 / r;
				var x;
				var y;
				while (true) {
					x = hz * wn[iz];
					if (iz == 0) {
						x = (-Math.log(UNI()) * r1);
						y = -Math.log(UNI());
						while (y + y < x * x) {
							x = (-Math.log(UNI()) * r1);
							y = -Math.log(UNI());
						}
						return (hz > 0) ? r + x : -r - x;
					}

					if (fn[iz] + UNI() * (fn[iz - 1] - fn[iz]) < Math.exp(-0.5 * x * x)) {
						return x;
					}
					hz = SHR3();
					iz = hz & 127;

					if (Math.abs(hz) < kn[iz]) {
						return (hz * wn[iz]);
					}
				}
			}

			function SHR3() {
				var jz = jsr;
				var jzr = jsr;
				jzr ^= (jzr << 13);
				jzr ^= (jzr >>> 17);
				jzr ^= (jzr << 5);
				jsr = jzr;
				return (jz + jzr) | 0;
			}

			function UNI() {
				return 0.5 * (1 + SHR3() / -Math.pow(2, 31));
			}

			function zigset() {
				// seed generator based on current time
				jsr ^= new Date().getTime();

				var m1 = 2147483648.0;
				var dn = 3.442619855899;
				var tn = dn;
				var vn = 9.91256303526217e-3;

				var q = vn / Math.exp(-0.5 * dn * dn);
				kn[0] = Math.floor((dn / q) * m1);
				kn[1] = 0;

				wn[0] = q / m1;
				wn[127] = dn / m1;

				fn[0] = 1.0;
				fn[127] = Math.exp(-0.5 * dn * dn);

				for (var i = 126; i >= 1; i--) {
					dn = Math.sqrt(-2.0 * Math.log(vn / dn + Math.exp(-0.5 * dn * dn)));
					kn[i + 1] = Math.floor((dn / tn) * m1);
					tn = dn;
					fn[i] = Math.exp(-0.5 * dn * dn);
					wn[i] = dn / m1;
				}
			}
			zigset();
		}

		var rnd = new Ziggurat();
		
		function createSlider(container, name, label, defaultValue) {
			var html = "<div><span id='"+ name +"Label'>" + label + "&nbsp;&nbsp;</span>";
			html += "<input id='"+name+"Slider' value='"+defaultValue+ "' type='range' min='0' max='100' style='width: 300px;'>";
			html += "&nbsp;&nbsp;<span id='"+name+"Value'>" + defaultValue + "</span></div>";
			container.insertAdjacentHTML('beforeend', html);
			Settings[name] = defaultValue;

			var slider = document.getElementById(name + "Slider");
			var value = document.getElementById(name + "Value");
			slider.addEventListener('input', function() {
				Settings[name] = slider.value;
				value.innerHTML = slider.value;
			});
			return slider;
		}

		function run() {
			var link = document.getElementById("run");
			if (Settings.run) {
				link.innerHTML = "MCMC (Gibbs) Sample";
				scene.remove(sampleObject);
				sampleData = null;
			} else {
				link.innerHTML = "Stop";
				totalSamples = 0;
			}
			window.requestAnimationFrame(updateParameters);
		}

		ui.insertAdjacentHTML('beforeend', "<h3>Model (Gaussian mixture):</h3>");
		createSlider(ui, "numberOfGaussians", "Number of Gaussians", 4).addEventListener('input', function() {
				updateParameters();
				render();
			});
		createSlider(ui, "gaussianDeviation", "Standard deviation", 2).addEventListener('input', function() {
					addGaussiansToScene();
		samplePointsFromGaussians();
				addPointsToScene();
				render();
			});
		createSlider(ui, "numberOfPoints", "Sample points", 50).addEventListener('input', function() {
				samplePointsFromGaussians();
				addPointsToScene();
				render();
			});
		
		ui.insertAdjacentHTML('beforeend', "<p></p><div><a class=toggle id=run href='javascript:run();' >MCMC (Gibbs) Sample</a> </div>");

		if (!Detector.webgl)
			Detector.addGetWebGLMessage();

		var terrainWidth = 40;
		var terrainDepth = 40;
		var terrainHalfWidth = terrainWidth / 2;
		var terrainHalfDepth = terrainDepth / 2;
		var terrainMaxHeight = 8;
		var terrainMinHeight = 0;

		// Graphics variables
		var terrainMesh, texture;
		var heightData = null;
		var sampleData = null;
		var depthMaterial;
		var depthRenderTarget;
		
		var container, stats;
		var params = {
			projection : 'normal',
			background : false,
			exposure : 1.0,
			bloomStrength : 1.5,
			bloomThreshold : 0.85,
			bloomRadius : 0.4,
			metalness: 0.0,
			brokenImpl: false
		};
		var camera, scene, renderer, controls;
		var effectFXAA, bloomPass, renderScene;
		var hdrCubeMap;
		var composer;
		var standardMaterial;
		var hdrCubeRenderTarget;

		var sampleGeometry;
		var sampleBins = 60;
		var sampleObject = null;
		var globalMax = 0;
		
		var currentPoints = [];
		var currentGaussians = [];
		
		init();
		updateParameters();
		
		animate();
		var totalSamples = 0;
		
		var redMaterial = new THREE.MeshPhongMaterial({
				map : null,
				color : 0xff3333,
				metalness : 0.0,
				shading : THREE.SmoothShading,
				specular: 0x111111,
				shininess: 430
			});
			
		var blueMaterial = new THREE.MeshPhongMaterial({
				map : null,
				color : 0x5544ff,
				metalness : 0.15,
				shading : THREE.SmoothShading,
				specular: 0x111111,
				shininess: 430
			});
			
		var blueGaussianMaterial =new THREE.MeshStandardMaterial({
					map : null,
					color : 0x4444ff,
					metalness : 0.00,
					//side : THREE.DoubleSide,
					transparent : false,
					opacity : 0.8,
					shading : THREE.SmoothShading,
					wireframe : true
				});
				
		var redGaussianMaterial =new THREE.MeshStandardMaterial({
					map : null,
					color : 0xff4444,
					metalness : 0.00,
					//side : THREE.DoubleSide,
					transparent : false,
					opacity :  0.8,
					shading : THREE.SmoothShading,
					wireframe : true
				});

		// Max is included
		function getRandomInt(max) {
			return Math.floor(Math.random() * (max+1));
		}
		
		function createPoint(x,y,clazz) {
			return { x: x, y: y, clazz: clazz };
		}
		
		function createGaussian(x,y,stdDev, clazz) {
			return { x: x, y: y, stdDev: stdDev, clazz: clazz };
		}
		

		function updateParameters() {
			buildGaussians();
			addGaussiansToScene();
			samplePointsFromGaussians();
			addPointsToScene();
		}
		
		function addGaussiansToScene() 
		{
			for (var i = 0; i < currentGaussians.length; i++) {
				scene.remove(currentGaussians[i]);
				currentGaussians[i].geometry.dispose();
			}
			currentGaussians = [];
			
			for (var g = 0; g < Settings.numberOfGaussians; g++) {
				var gaussian = Settings.gaussians[g];
				
				var pbGeometry = new THREE.PlaneBufferGeometry(100, 100, terrainWidth - 1, terrainDepth - 1);
				pbGeometry.rotateX(-Math.PI / 2);
				var vertices = pbGeometry.attributes.position.array;
				
				var p = 0;
				for (var j = 0; j < terrainDepth; j++) {
					for (var i = 0; i < terrainWidth; i++, p+=3) {
						var x = 100*((i / terrainDepth)-0.5);
						var y = 100*((j / terrainDepth)-0.5);
						
						var dx = x-gaussian.x;
						var dy = y-gaussian.y;
						var s = gaussian.stdDev;		
						var z = Math.exp(-dx*dx / (s*s*2));
						z = z*Math.exp(-dy*dy / (s*s*2));
			
						vertices[p + 1] = z*20.0-0.5-g*0.1;
					}
				}
				
				pbGeometry.verticesNeedUpdate = true;
				pbGeometry.normalsNeedUpdate = true;
				pbGeometry.attributes.position.needsUpdate = true;
				pbGeometry.computeVertexNormals();
				
				var mesh = new THREE.Mesh(pbGeometry, gaussian.clazz<0 ? blueGaussianMaterial : redGaussianMaterial);
				
				mesh.receiveShadow = false;
				mesh.castShadow = false;

				scene.add(mesh);
				currentGaussians.push(mesh);
			}
		}
		
		var sphereGeometry = new THREE.SphereGeometry(1.5,10,10);
				
		
		function addPointsToScene() {
			for (var i = 0; i < currentPoints.length; i++) {
				scene.remove(currentPoints[i]);
			}
			currentPoints = [];
			
			for (var i = 0; i <  Settings.numberOfPoints; i++) {
				var p = Settings.points[i];
				
				var dataPoint = new THREE.Mesh(sphereGeometry, p.clazz > 0 ? redMaterial : blueMaterial);
				dataPoint.position.set(p.x, 0, p.y);
				scene.add(dataPoint);
				currentPoints.push(dataPoint);
				dataPoint.scale.set(1,1,1);
				dataPoint.receiveShadow = true;
				dataPoint.castShadow = true;
			}	
		
				
		}
		
		function buildGaussians() {
			Settings.gaussians = [];
			for (var i = 0; i < Settings.numberOfGaussians; i++) {
				var x = Math.random()*100-50;
				var y = Math.random()*100-50;
				Settings.gaussians.push(createGaussian(x,y, 10, i%2==0 ? 1 : -1 ));
			}
		};

		function samplePointsFromGaussians() {
			Settings.points = [];
			for (var i = 0; i < Settings.numberOfPoints; i++) {
				var gaussian = Settings.gaussians[getRandomInt(Settings.numberOfGaussians-1)];
						
				var p = createPoint(
							gaussian.x + rnd.nextGaussian()*gaussian.stdDev,
							gaussian.y + rnd.nextGaussian()*gaussian.stdDev,
							gaussian.clazz);
				Settings.points.push(p);
			}
		};

		function init() {
			container = document.createElement('div');
			document.body.appendChild(container);

			camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 2000);
			camera.position.set(0.0, 35, 35 * 3.5);

			scene = new THREE.Scene();

			renderer = new THREE.WebGLRenderer({
				antialias : false
			});
			renderer.setClearColor(new THREE.Color(0x222222));
			renderer.toneMapping = THREE.LinearToneMapping;
			renderer.shadowMapType = 2;

			

			
			var geometry = new THREE.PlaneBufferGeometry(100, 100, terrainWidth - 1, terrainDepth - 1);
			geometry.rotateX(-Math.PI / 2);
			meshGeometry = geometry;

			//updateGeometry();
			
			

			terrainMesh = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({
				map : null,
				color : 0xffffff,
				metalness : 0.00,
				side : THREE.DoubleSide,
				shading : THREE.SmoothShading
			}));
			terrainMesh.receiveShadow = true;
			terrainMesh.castShadow = true;

			scene.add(terrainMesh);

			
			var genCubeUrls = function(prefix, postfix) {
				return [ prefix + 'px' + postfix, prefix + 'nx' + postfix, prefix + 'py' + postfix, prefix + 'ny' + postfix,
						prefix + 'pz' + postfix, prefix + 'nz' + postfix ];
			};

			var hdrUrls = genCubeUrls("./js/cube/pisaHDR/", ".hdr");
			new THREE.HDRCubeTextureLoader().load(THREE.UnsignedByteType, hdrUrls, function(hdrCubeMap) {

				var pmremGenerator = new THREE.PMREMGenerator(hdrCubeMap);
				pmremGenerator.update(renderer);

				var pmremCubeUVPacker = new THREE.PMREMCubeUVPacker(pmremGenerator.cubeLods);
				pmremCubeUVPacker.update(renderer);

				hdrCubeRenderTarget = pmremCubeUVPacker.CubeUVRenderTarget;

			});

			// Lights

			scene.add(new THREE.AmbientLight(0x222222));

			var spotLight = new THREE.SpotLight(0xffffff);
			spotLight.position.set(50, 100, 50);
			spotLight.angle = Math.PI / 5;
			spotLight.penumbra = 0.1;
			spotLight.castShadow = true;
			spotLight.shadowMapWidth = 1024; // default is 512
			spotLight.shadowMapHeight = 1024; // default is 512
			scene.add(spotLight);

			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.shadowMap.enabled = true;
			container.appendChild(renderer.domElement);

			renderScene = new THREE.RenderPass(scene, camera);

			// renderScene.clear = true;
			effectFXAA = new THREE.ShaderPass(THREE.FXAAShader);
			effectFXAA.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);

			var copyShader = new THREE.ShaderPass(THREE.CopyShader);
			copyShader.renderToScreen = true;

			// Setup depth pass
				depthMaterial = new THREE.MeshDepthMaterial();
				depthMaterial.depthPacking = THREE.RGBADepthPacking;
				depthMaterial.blending = THREE.NoBlending;
			
				var pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter };
			depthRenderTarget = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, pars );

			// Setup SSAO pass
					ssaoPass = new THREE.ShaderPass( THREE.SSAOShader );
				ssaoPass.renderToScreen = true;
				//ssaoPass.uniforms[ "tDiffuse" ].value will be set by ShaderPass
				ssaoPass.uniforms[ "tDepth" ].value = depthRenderTarget.texture;
				ssaoPass.uniforms[ 'size' ].value.set( window.innerWidth, window.innerHeight );
				ssaoPass.uniforms[ 'cameraNear' ].value = camera.near;
				ssaoPass.uniforms[ 'cameraFar' ].value = camera.far;
				ssaoPass.uniforms[ 'onlyAO' ].value = false;
				ssaoPass.uniforms[ 'aoClamp' ].value = 0.3;
				ssaoPass.uniforms[ 'lumInfluence' ].value = 0.5;

			
			var shaderVignette = THREE.VignetteShader;
			var effectVignette = new THREE.ShaderPass(shaderVignette);
			effectVignette.uniforms["offset"].value = 0.95;
			effectVignette.uniforms["darkness"].value = 2.0;
			var effectFilm = new THREE.FilmPass(0.55, 0.525, 1048, false);

			bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);//1.0, 9, 0.5, 512);
			composer = new THREE.EffectComposer(renderer);
			composer.setSize(window.innerWidth, window.innerHeight);
			composer.addPass(renderScene);
			composer.addPass(effectFXAA);
			composer.addPass(bloomPass);
			composer.addPass(effectVignette);
			composer.addPass(effectFilm);
			composer.addPass(ssaoPass);
			
			renderer.toneMapping = THREE.ReinhardToneMapping;
			renderer.gammaInput = true;
			renderer.gammaOutput = true;

			stats = new Stats();
			container.appendChild(stats.dom);

			controls = new THREE.OrbitControls(camera, renderer.domElement);
			controls.update();
			controls.addEventListener( 'change', render );

			window.addEventListener('resize', onWindowResize, false);

			var gui = new dat.GUI();

			gui.add(params, 'exposure', 0.1, 2);
			gui.add(params, 'bloomThreshold', 0.0, 1.0).onChange(function(value) {
				bloomPass.threshold = Number(value);
			});
			gui.add(params, 'bloomStrength', 0.0, 3.0).onChange(function(value) {
				bloomPass.strength = Number(value);
			});
			gui.add(params, 'bloomRadius', 0.0, 1.0).onChange(function(value) {
				bloomPass.radius = Number(value);
			});
			gui.add(params, 'metalness', 0.0, 1.0).onChange(function(value) {
				if (terrainMesh.material !== undefined) 
					terrainMesh.material.metalness = Number(value);
			});
			gui.add(params, 'brokenImpl').onChange(function(value) {
				Settings.brokenImpl = value;
			});
			gui.open();
			render();

		}

		

		function onWindowResize() {
			var width = window.innerWidth;
			var height = window.innerHeight;

			camera.aspect = width / height;
			camera.updateProjectionMatrix();

			renderer.setSize(width, height);
			composer.setSize(width, height);
			effectFXAA.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
		}

		function animate() {
			requestAnimationFrame(animate);
			controls.update(0.01);

		}

		var count = 0;
		
		function render() {
			
			console.log("Render():" + count++);
			
			if (standardMaterial !== undefined) {
				standardMaterial.roughness = 0.0;
				standardMaterial.bumpScale = -0.05;
				var newEnvMap = standardMaterial.envMap;
				newEnvMap = hdrCubeRenderTarget ? hdrCubeRenderTarget.texture : null;
				if (newEnvMap !== standardMaterial.envMap) {
				//	standardMaterial.envMap = newEnvMap;
					//standardMaterial.needsUpdate = true;
				}
			}
			renderer.toneMappingExposure = Math.pow(params.exposure, 4.0);
			var timer = Date.now() * 0.00025;
			camera.lookAt(scene.position);
			
			
			// Render depth into depthRenderTarget
					scene.overrideMaterial = depthMaterial;
					renderer.render( scene, camera, depthRenderTarget, true );
					// Render renderPass and SSAO shaderPass
					scene.overrideMaterial = null;
					
			composer.render(0.01);
		}

		
	</script>

</body>
</html>
